 for (i = 0; i < num_of_samples; i++) {
      /* Copy one sample */
      if (haudio->bit_depth == 16U) {
        /* { 0: L_LOBYTE, 1: L_HIBYTE, 2: R_LOBYTE, 3: R_HIBYTE } */
        haudio->buffer[haudio->wr_ptr++] = (uint16_t)(tmpbuf[tmpbuf_ptr] << 8);
        haudio->buffer[haudio->wr_ptr++] = (uint16_t)(tmpbuf[tmpbuf_ptr + 1]);
        haudio->buffer[haudio->wr_ptr++] = (uint16_t)(tmpbuf[tmpbuf_ptr + 2] << 8);
        haudio->buffer[haudio->wr_ptr++] = (uint16_t)(tmpbuf[tmpbuf_ptr + 3]);
        tmpbuf_ptr += 4;
      } else {
        /* { 0: L_LOBYTE, 1: L_MDBYTE, 2: L_HIBYTE, 3: R_LOBYTE, 4: R_MDBYTE, 5: R_HIBYTE } */
        haudio->buffer[haudio->wr_ptr++] = *(uint16_t*)&tmpbuf[tmpbuf_ptr];
        haudio->buffer[haudio->wr_ptr++] = (uint16_t)(tmpbuf[tmpbuf_ptr + 2]);
        haudio->buffer[haudio->wr_ptr++] = *(uint16_t*)&tmpbuf[tmpbuf_ptr + 3];
        haudio->buffer[haudio->wr_ptr++] = (uint16_t)(tmpbuf[tmpbuf_ptr + 5]);
        tmpbuf_ptr += 6;
      }

      /* Rollback if reach end of buffer */
      if (haudio->wr_ptr >= AUDIO_TOTAL_BUF_SIZE) {
        haudio->wr_ptr = 0U;
      }
    }